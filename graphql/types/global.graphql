input InvoiceDataInput {
  id: String
  name: String
  email: String
  startDate: String
  endDate: String
}

input SettingsDataInput {
  id: String
  startCycle: String
}

type SettingsSeller {
  id: String
  startCycle: String
}


type Invoice {
  status: String
  invoiceCreatedDate: String
  seller: SellerInvoiceData
  orders: [Order]
  totalizers: Totalizers
  comment: String
}

type InvoiceList {
  id: String
  status: String
  invoiceCreatedDate: String
  totalizers: Totalizers
}

type Totalizers {
  subtotal: Float
  fee: Float
  total: Float
}

type Order {
  orderId: String
  sellerOrderId: String
  totalComission: Float
  totalOrderValue: Float
  totalOrderRate: Float
}

type SellerInvoiceData {
  id: String
  name: String
  contact: SellerContact
}

type SellerContact {
  phone: String
  email: String
}

type PaginatedSellers {
  sellers: [Seller]
  pagination: PaginationSearch
}

type Seller {
  id: String
  name: String
  account: String
  productCommissionPercentage: Int
  freightCommissionPercentage: Int
  isActive: Boolean
}

input Dates {
  startDate: String
  endDate: String
}

input Pagination {
  page: Int
  pageSize: Int
}

type SearchResponse {
  dateStart: String
  dateEnd: String
  sellers: [SellersDashboardSearch]
  statistics: StatsGeneralSearch
  pagination: PaginationSearch
}

type SellersDashboardSearch {
  id: String
  name: String
  account: String
  statistics: StatsSellerSearch
}

type StatsSellerSearch {
  dateInvoiced: String
  ordersCount: Int
  totalComission: Float
  totalOrderValue: Float
  outstandingBalance: Float
}

type PaginationSearch {
  currentPage: Int
  pageSize: Int
  totalPage: Int
}

input SearchDashboardParams {
  dateStart: String!
  dateEnd: String!
  sellersId: String
  page: Int!
  pageSize: Int!
}

type SearchStatsResponse {
  dateStart: String
  dateEnd: String
  statistics: StatsGeneralSearch
}

type StatsGeneralSearch {
  ordersCount: Int
  totalComission: Float
  totalOrderValue: Float
}

input SearchStatsDashboardParams {
  dateStart: String!
  dateEnd: String!
}

input SearchOrdersParams {
  dateStart: String!
  dateEnd: String!
  sellerName: String!
  page: Int!
  perpage: Int!
  status: String
}

type OrderSearch {
  orderId: String
  sellerOrderId: String
  marketplaceOrderId: String
  totalComission: Float
  totalOrderValue: Float
  status: String
  statusDescription: String
  creationDate: String
  rate: [ItemsRateOrdersSearch]
}

type ItemsRateOrdersSearch {
  itemId: String
  nameItem: String
  rate: RateOrders
}

type RateOrders {
  productCommissionPercentage: Float
  freightCommissionPercentage: Float
}

type PagingOrders {
  total: Int
  pages: Int
  currentPage: Int
  perPage: Int
}

type SearchOrdersResponse {
  data: [OrderSearch]
  paging: PagingOrders
}

type CreateTokenResponse {
  message: String
  sellerId: String
  autheticationToken: String
  creationDate: String
  resultVBase: [ResultVBase]
}

type ResultVBase {
  path: String
  hash: String
}

input TokenInput {
  enabled: Boolean
}

type EditTokenResponse {
  message: String
  sellerId: String
  lastModificationDate: String
  resultVBase: [ResultVBase]
}

type GetTokenResponse {
  id: String
  account: String
  name: String
  autheticationToken: String
  creationDate: String
  lastModificationDate: String
  enabled: Boolean
}

input ListSellersParams {
  sellersId: String
  page: Int
  pageSize: Int
}

input SellerInvoiceParams{
  sellerName: String!
  pagination: Pagination
  dates: Dates!
}
